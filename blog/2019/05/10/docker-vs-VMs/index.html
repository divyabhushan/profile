<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.ff31de0ff">
<link rel="alternate" type="application/rss+xml" href="/profile/blog/rss.xml" title="Divya Bhushan Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/profile/blog/atom.xml" title="Divya Bhushan Blog Atom Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-139623144-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-139623144-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script><title data-react-helmet="true">Docker Vs Virtual Machines(VMs) | Divya Bhushan</title><meta data-react-helmet="true" property="og:title" content="Docker Vs Virtual Machines(VMs) | Divya Bhushan"><meta data-react-helmet="true" name="description" content="Virtualization comes in handy with the need of running multiple simulated environments in a single machine without installing and configuring each instance. Virtualization has its used cases in many scenarios such as testing your app in multiple environments/devices."><meta data-react-helmet="true" property="og:description" content="Virtualization comes in handy with the need of running multiple simulated environments in a single machine without installing and configuring each instance. Virtualization has its used cases in many scenarios such as testing your app in multiple environments/devices."><meta data-react-helmet="true" property="og:url" content="https://github.com/divyabhushan/profile/profile/blog/2019/05/10/docker-vs-VMs"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><link data-react-helmet="true" rel="shortcut icon" href="/profile/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://github.com/divyabhushan/profile/profile/blog/2019/05/10/docker-vs-VMs"><link data-react-helmet="true" rel="alternate" href="https://github.com/divyabhushan/profile/profile/blog/2019/05/10/docker-vs-VMs" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://github.com/divyabhushan/profile/profile/blog/2019/05/10/docker-vs-VMs" hreflang="x-default"><link rel="stylesheet" href="/profile/assets/css/styles.354a6d11.css">
<link rel="preload" href="/profile/assets/js/runtime~main.96f30e45.js" as="script">
<link rel="preload" href="/profile/assets/js/main.74a5d44d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/profile/"><strong class="navbar__title">Home</strong></a><a class="navbar__item navbar__link" href="/profile/docs/synopsis">Synopsis</a><a class="navbar__item navbar__link" href="/profile/history">Job History</a><a class="navbar__item navbar__link" href="/profile/techDocs">Technical Documentation</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/profile/articles">My Articles</a></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/profile/"><strong class="navbar__title">Home</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/profile/docs/synopsis">Synopsis</a></li><li class="menu__list-item"><a class="menu__link" href="/profile/history">Job History</a></li><li class="menu__list-item"><a class="menu__link" href="/profile/techDocs">Technical Documentation</a></li><li class="menu__list-item"><a class="menu__link" href="/profile/articles">My Articles</a></li></ul></div></div></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_2ahu thin-scrollbar"><h3 class="sidebarItemTitle_2hhb">Recent posts</h3><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/profile/blog/2019/06/10/devops-interview-questions-answers">DevOps Interview Questions and Answers - Part I - Basics</a></li><li class="sidebarItem_2UVv"><a aria-current="page" class="sidebarItemLink_1RT6 sidebarItemLinkActive_12pM" href="/profile/blog/2019/05/10/docker-vs-VMs">Docker Vs Virtual Machines(VMs)</a></li></ul></div></div><main class="col col--7"><article><header><h1 class="margin-bottom--sm blogPostTitle_GeHD">Docker Vs Virtual Machines(VMs)</h1><div class="margin-vert--md"><time datetime="2019-05-10T00:00:00.000Z" class="blogPostDate_fNvV">May 10, 2019 · 21 min read</time></div><div class="avatar margin-vert--md"><a href="https://github.com/divyabhushan" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars0.githubusercontent.com/u/11659160?" alt="Divya Bhushan"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/divyabhushan" target="_blank" rel="noopener noreferrer">Divya Bhushan</a></h4><small class="avatar__subtitle"></small></div></div></header><div class="markdown"><p><strong>Virtualization</strong> comes in handy with the need of running <em>multiple simulated</em> environments in a single machine without installing and configuring each instance. Virtualization has its used cases in many scenarios such as testing your app in multiple environments/devices.</p><p>Both Dockers and Virtual Machines(VMs) are capable of providing virtualized runtime environments for your software/hardware needs.</p><p>This article is aimed at providing a basic understanding of the common and unique features each Docker and a VM possess.</p><p>When you deal with multiple platforms with customized hardware/software specifications, you need to have an effective resource management in place. </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-a-machine-needs"></a>What a machine needs?<a class="hash-link" href="#what-a-machine-needs" title="Direct link to heading">#</a></h2><p>Each computing environment(machine) needs its component of <em>hardware resources</em> and <em>software resources.</em></p><p>As more and more machines are needed, building up and administering many such stand-alone machines is not only cumbersome, time-consuming but also adds up to the cost and energy.</p><p>Apparently; to run a customized <em>High-power</em> <em>Scalable</em> <em>Server</em> is a better idea to consolidate all the hardware and software requirements into one place and have a single server run and distribute the resources to many machines over a network.</p><p>That saves us time, resources, energy and revenue.</p><p>These gigantic servers are stored in a data warehouse called a <em>Datacenter__.</em></p><p>Below Diagram (2) indicates a single <em>server</em> serving and sharing resources and data among multiple client machines</p><p>Does this look simplified enough? Yes of course!</p><p>So, this setup looks feasible we have a high-power, high-storage Server that gives resources to many smaller(resources) machines over a network.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="how-to-manage-huge-data---servers"></a><strong>How to manage huge data - Servers</strong><a class="hash-link" href="#how-to-manage-huge-data---servers" title="Direct link to heading">#</a></h2><p>With <em>Internet Of Things</em> in boom, Information is over-flowing with a huge amount of data; handling tremendous data needs more system resources which means more _Dedicated server_s are needed.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="many-servers-approach-challenge"></a><strong>Many Servers approach challenge:</strong><a class="hash-link" href="#many-servers-approach-challenge" title="Direct link to heading">#</a></h3><p>Running several <em>Dedicated servers</em> for specific services such as Web service, application or database service as indicated in Diagram (3) is difficult to administer and consumes more energy, resources, manpower and is highly expensive.</p><p>In addition; resource utilization of servers is very poor resulting in resource wastage.</p><p>This is where simulating different environments and running them all on a single server is a smart choice; rather than having to run multiple physically distinct servers.</p><p>This is how Diagram (3) would change after consolidating different servers into one as shown in Diagram (4).</p><p>Sheet 2</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="virtualization"></a><strong>Virtualization</strong><a class="hash-link" href="#virtualization" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-virtualization"></a>What is Virtualization<a class="hash-link" href="#what-is-virtualization" title="Direct link to heading">#</a></h3><p>The above single server implementation can be defined as the following term.</p><p><em>Virtualization</em> is a technique used to simulate and <em>pretend a single infrastructure</em> resource (<em>hardware resources</em> and <em>software resources</em>) <em>to be acting as many</em> providing multiple functionalities or services without the need to physically build, install and configure.</p><p>In other words;</p><p>Running <em>multiple simulated environments in a single machine without installing and configuring them</em> is called <em>Virtualization</em>.</p><p>Technically speaking;</p><p>Virtualization is an abstract layer that shares the infrastructure resources among various simulated <em>virtual machines</em> without the need to physically set up these environments.</p><p>Diagram (5) displays different virtual Operating systems are running on the same machine and using the same hardware architecture of the underlying machine.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-a-virtual-machine"></a><em>What is a Virtual machine</em><a class="hash-link" href="#what-is-a-virtual-machine" title="Direct link to heading">#</a></h3><p>The simulated virtualized environments are called virtual machines or VM.</p><p>Virtual machine is a <em>replication/simulation</em> of an actual physical machine.</p><p>A VM acts like a real physical machine and uses the physical resources of the underlying host OS.</p><p>A VM is a running <em>instance of a real physical machine.</em></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="need-for-virtualization"></a><em>Need</em> <em>for</em> <em>virtualization</em><a class="hash-link" href="#need-for-virtualization" title="Direct link to heading">#</a></h3><p>So; we have an overview of virtualization, let us examine when should we virtualize and what are the benefits of virtualization?</p><ol><li><strong>Better resource management and</strong> <strong>cost-effective</strong>: as indicated in Diagram (6) and Diagram (7); hardware resources are distributed wisely on need basis to different environments; all the virtual machines share the same resources and reduce resource wastage.</li><li><strong>Ease of quick administration and maintenance</strong>: It is easier to build, install, configure one server rather than multiple servers. Updating a patch on various machines from a single virtualized server is much more feasible.</li><li><strong>Disaster recovery</strong>: Since all the virtualized machines reside on the same server and are treated as mounted volumes of data files, it is easier to back up these machines. In case of a disaster failure (power failure, network down, cyber-attacks, failed test code, etc) VM screenshots are used to recover the running state of the machine and the whole setup can be built up within minutes.</li><li><strong>Isolated and independent secure test environment</strong>: virtualization provide an isolated independent virtual test environment to test the legacy code or a vendor-specific product or even a beta release or say a corrupt code without affecting the main hardware and software platform. (This is a contradictory statement though; will discuss more under types of virtualization)<br>These test environments like dev, uat, preprod, prod etc..can be easily tested and discarded.</li><li><strong>Easily scalable and upgradable</strong>: Building up more simulated environments means spinning up more virtual machines. Also upgrading VMs is as good as to run a patch in all VMs.</li><li><strong>Portable</strong>: Virtual machines are lightweight compared to the actual running physical machines; in addition, a VM that includes its own OS, drivers, and other installation files is portable on any machine. One can access the data virtually from any location.</li></ol><p>The screenshot of activity monitor below compares the CPU load:</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="implementation"></a><em>Implementation</em><a class="hash-link" href="#implementation" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="a-what-is-hypervisor-and-its-types__"></a><em>a) What is hypervisor and its types__?</em><a class="hash-link" href="#a-what-is-hypervisor-and-its-types__" title="Direct link to heading">#</a></h3><p>As discussed in the previous section; virtualization is achieved by means of a virtualized layer on top of hardware or a software resource.</p><p>This abstract layer is called a <em>hypervisor.</em></p><p>A hypervisor is a virtual machine monitor (VMM)</p><p>There are 2 types of hypervisors: Diagram (8)</p><ol><li>Type-1 or bare-metal hypervisor</li><li>Type-2 or hosted hypervisor</li></ol><p><em>Type-1 or bare-metal</em> hypervisor is installed directly on the system hardware, thus abstracting and sharing the hardware components with the VMs.</p><p><em>Type-2 or hosted hypervisor</em> is installed on top of the system bootable OS called host OS; this hypervisor abstracts the system resources visible to the host OS and distributes it among the VMs.</p><p>Both have their own role to play in virtualization.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="b-comparing-hypervisor-types"></a><em>b) Comparing hypervisor types</em><a class="hash-link" href="#b-comparing-hypervisor-types" title="Direct link to heading">#</a></h3><p>Type-1 or bare-metal hypervisor</p><p>Type-2 or hosted hypervisor</p><p>Installed <em>directly on the infrastructure</em>-OS independent and more secure against software issues.</p><p>Installed <em>on top of the host OS</em>-more prone to software failures.</p><p><em>Better resource flexibility</em>: Have direct access to the hardware infrastructure (Hard-drive partition, RAM, embedded cards such as NIC). Provide more flexibility and scalability to the VMs and assign resources on a need basis.</p><p><em>Limited resource allocation</em>: Have access to just the resources exposed by the host OS.</p><p>VMs installed will have limited access to hardware resources allocated and exposed by the host OS.</p><p>Single point of failure: A compromised VM may affect the kernel. Extra security layers needed.</p><p>A compromised VM may affect only the host OS, kernel still remains unreachable.</p><p>Low latency due to direct link to the infrastructure.</p><p>High latency as all the VMs have to pass through the OS layer to access the system resources.</p><p>Generally used in Servers</p><p>Generally used on small client machines</p><p>Expensive</p><p>Less expensive</p><p>Type-1 Hypervisors in market:</p><p>VMWare ESX/ESXi</p><p>Hyperkit (OSX)</p><p>Microsoft Hyper-V (Windows)<br>
KVM(Linux)</p><p>Oracle VM Server</p><p>Type-2 Hypervisors in market:</p><p>Oracle VM VirtualBox</p><p>VMWare Workstation</p><p>Parallels desktop for MAC</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="types-of-virtualization"></a><em>Types of virtualization</em><a class="hash-link" href="#types-of-virtualization" title="Direct link to heading">#</a></h2><p>Based on what resource is virtualized, there are different classifications of virtualization.</p><p>Server, Storage device, operating system, network</p><p><strong>Desktop</strong> <strong>virtualization</strong>: Entire desktop environment is simulated and distributed to run on a single server all at once. A desktop virtualization allows administrators to manage, install, configure similar setups on many machines. Upgrading all the machines with a single patch update or security checks becomes easier and faster.</p><p><strong>Server</strong> <strong>virtualization</strong>: Many dedicated servers can be virtualized into a single server that provides multi-server functionality.</p><p><strong>Example:</strong></p><p>Many virtual machines can be built up sharing the same underlying system resources.</p><p>Storage, RAM, disks, CPU</p><p><strong>Operating system</strong> <strong>virtualization</strong>: This happens at the kernel level Hypervisor on hardware type 2 bare-metal One machine: Can boot up as multiple OS like Windows or Linux side-by-side</p><p><strong>Application virtualization</strong>: Apps are packaged and stored in a virtual environment and are distributed across different VMs. Example Microsoft applications like excel, MS word, Powerpoint etc, Citrix applications.</p><p><strong>Network functions virtualization</strong>: Physical network components such as NIC cards, switches, routers, servers, hubs, and cables are all assembled in a single server and used virtually by multiple machines without having the load of installing them on every machine.</p><p>Virtualization is one of the building blocks and driving force behind <a href="https://www.ibm.com/cloud/learn/cloud-computing" target="_blank" rel="noopener noreferrer"><em>cloud computing</em></a>.</p><p>Cloud computing provide virtualized need-based services. This has given an uplift to the concept of virtualization.</p><p>A quick mention of various cloud computing models/services are listed below:</p><p><strong>SaaS</strong> – Software as a Service– end-user applications are maintained and run by service providers and easily distributed and used by the end users without having to install them.</p><p>Top SaaS providers: Microsoft (Office suite, CRM, SQL server databases), AWS, Adobe, Oracle (ERP, CRM, SCM), Cisco’s <a href="https://www.webex.com/de/index.html" target="_blank" rel="noopener noreferrer">Webex</a>, <a href="https://github.com/" target="_blank" rel="noopener noreferrer">GitHub</a> ( git hosting web service)</p><p><strong>PaaS</strong> – Platform as a Service – computing infrastructure(hardware/software) is maintained and updated by the service provider and the user just have to run the product over this platform.</p><p>Top Paas providers: <a href="https://aws.amazon.com/elasticbeanstalk/" target="_blank" rel="noopener noreferrer">AWS beanstalk</a>, <a href="https://www.oracle.com/index.html" target="_blank" rel="noopener noreferrer">Oracle Cloud Platform (OCP)</a>, <a href="https://cloud.google.com/appengine/" target="_blank" rel="noopener noreferrer">Google App Engine</a></p><p><strong>IaaS</strong> – Infrastructure as a Service – Provide infrastructure such as servers, physical storage, networking, memory devices etc. Users can build their own platform with customized operating system and applications.</p><p>Key IaaS providers: Amazon Web Services, <a href="https://azure.microsoft.com/en-us/" target="_blank" rel="noopener noreferrer">Microsoft Azure</a>, Google compute engine, Citrix</p><p><strong>Conclusion:</strong></p><p>We now have a fair understanding of types of virtualization and how they are implemented.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="containerization"></a><strong>Containerization</strong><a class="hash-link" href="#containerization" title="Direct link to heading">#</a></h2><p>Though virtualization has its pros; there are certain downsides of virtualization such as:</p><ul><li>Not all systems can be virtualized always.</li><li>A corrupt VM is sometimes contagious and may affect other VMs or the kernel in-case of a <em>Type-1 or bare-metal</em> hypervisor.</li><li>Latency of virtual disks due to increased payload on the CPU resources with a higher number of VMs</li><li>Unstable performance</li></ul><p>An alternative approach to overcome the above flaws of virtualization is to <em>Containerize</em> the applications and the run-time environment together.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-containerization"></a><em>What is containerization</em><a class="hash-link" href="#what-is-containerization" title="Direct link to heading">#</a></h2><p><em>Containerization</em> is an OS-level virtualization; wherein the entire build of an application along with run-time environment is encapsulated or bundled up in a package.</p><p>These packages are called <em>containers</em>.</p><p>Containers are lightweight virtualized environments. These are independent of the infrastructure both hardware and software.</p><p>The run-time environment includes the operating system, binaries, libraries, configuration files and other applications as shown in Diagram (9).</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-a-docker"></a><em>What is a Docker</em><a class="hash-link" href="#what-is-a-docker" title="Direct link to heading">#</a></h2><p><em>Dockers</em> provide an excellent framework for containerization and allow to build, ship, and run distributed applications over multiple platforms.</p><p>Docker framework is setup as a <em>docker engine</em> installed on host OS and a <a href="https://www.knowledgehut.com/devops/docker-training" target="_blank" rel="noopener noreferrer">docker</a> <em>daemon</em> (background process) process is started that manage the virtual <em>containers</em>.</p><p>Refer Diagram (10) that shows a Docker engine with 3 containers residing on host OS (MAC OS).</p><p>An instruction file called <em>dockerfile</em> is written with a set of system commands that change the filesystem such as add, copy or delete commands, run commands, install utilities, system calls etc…</p><p>This <em>dockerfile</em> is built and packaged along with its run-time environment as an executable file called a <em>docker image.</em></p><p>Docker daemon services run these images to create <em>docker containers.</em></p><blockquote><p><em>Docker container is a run-time instance of an image</em></p></blockquote><p>It is wise to say that many images (or layers of instruction files) make up a container.</p><p>Docker containers have a compact packaging and each container is well isolated.</p><p>We can run, start, stop, attach, move or delete containers as these runs as services on the host OS.</p><p>Each image is made up of different layers; each image based on top of the other with the customized command changes that we make.</p><p>Every time we make a change in the filesystem, each change related to the image is encapsulated in a new layer of filesystem and stacked up above the parent image.</p><p>Only the changed layers are rebuilt, rest of the unchanged image layers are reused.</p><p>Certain docker commands ADD, RUN and COPY c<em>reate a new layer with increased byte size; rest of the commands simply adds up a new layer with zero-byte size.</em></p><p><em>These layers are re-used to build a new image, hence faster and lightweight.</em></p><p>Docker images are also</p><p>The layer approach of an image every time there is a change in the image makes it possible to Version control the docker images.</p><p>Here is a terminal recording that shows docker engine process and how images and containers are created.</p><p>Docker documentation - to <a href="https://docs.docker.com/get-started/part2/" target="_blank" rel="noopener noreferrer">create containers</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ppt-diagram"></a><strong>Ppt diagram:</strong><a class="hash-link" href="#ppt-diagram" title="Direct link to heading">#</a></h3><p>Code -&gt; package -&gt; build images -&gt; registry hub -&gt; download/pull image -&gt; run container</p><p>Animation: sheet4</p><p>Let’s consider the docker container: divyabhushan/learn_docker hosted on docker hub.</p><p>Latest tagged image: centOS_release1.2</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-the-container-environment"></a>What is the container environment?<a class="hash-link" href="#what-is-the-container-environment" title="Direct link to heading">#</a></h3><p>Base OS: Centos:7</p><p>Utilities: vim, yum, git</p><p>Apps/files: Dockerfile, myApp.sh, runtests.sh, data and other supporting files.</p><p>Git source code: <a href="https://github.com/divyabhushan/DockerImages_Ubuntu.git" target="_blank" rel="noopener noreferrer">dockerImages</a></p><p>Download as: git clone <a href="https://github.com/divyabhushan/DockerImages_Ubuntu.git" target="_blank" rel="noopener noreferrer">https://github.com/divyabhushan/DockerImages_Ubuntu.git</a></p><p>What does the container do?<br>
Container launches “myApp.sh” in Ubuntu:14.04 environment and run some scripts along with a set of post test_suites in the container (Ubuntu:14.04) and saves the output log file.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="how-to-modify-and-build-your-own-app"></a><em>How to modify and build your own app</em><a class="hash-link" href="#how-to-modify-and-build-your-own-app" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-1-pull"></a><strong>Step 1: pull</strong><a class="hash-link" href="#step-1-pull" title="Direct link to heading">#</a></h3><p><strong>1.1: Pull the docker image</strong></p><p><strong>1.2: Run image to create a container and exit</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-2-modify"></a><strong>Step 2: modify</strong><a class="hash-link" href="#step-2-modify" title="Direct link to heading">#</a></h3><p>2.1: Start the container</p><p>2.2: Attach to the container and make some changes</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-3-commit"></a><strong>Step 3: commit</strong><a class="hash-link" href="#step-3-commit" title="Direct link to heading">#</a></h3><p>3.1: Examine the history logs and changes in the container</p><p>3.2: Commit the changes in container</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-4-push"></a><strong>Step 4: push</strong><a class="hash-link" href="#step-4-push" title="Direct link to heading">#</a></h3><p>4.1: Push new image to docker hub</p><p>Let us see the steps in action:</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-1-pull-1"></a><strong>Step 1: pull</strong><a class="hash-link" href="#step-1-pull-1" title="Direct link to heading">#</a></h3><p>docker image on your machine</p><p>1.1: Pull the docker image</p><p><strong>Command:</strong></p><p>docker pull divyabhushan/learn_docker:myApp_ubuntu_14.04</p><p>View the image on system</p><p>docker images</p><p>screenshot</p><p><strong>Command:</strong></p><p>docker run -it --name ubuntu14.04 0a6f949131a6</p><p>Run command in ubuntu container and exit, the container is stopped on exiting out.</p><p>View the stopped container with the ‘ps -a’ command.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-2-modify-1"></a><strong>Step 2: modify</strong><a class="hash-link" href="#step-2-modify-1" title="Direct link to heading">#</a></h3><p>Start the container</p><p><strong>Command:</strong></p><p>docker start &lt;container_id&gt;</p><p>Now the container is listed as a running process Attach to the container and make some changes</p><p><strong>Command:</strong></p><p>docker attach 7d0d0225778c</p><p>edit the ‘git configuration’ file and ‘myApp.sh’ script</p><p>Container is modified and stopped</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-3-commit-1"></a><strong>Step 3: commit</strong><a class="hash-link" href="#step-3-commit-1" title="Direct link to heading">#</a></h3><p>Examine the history logs and changes in the container</p><p>The changes done inside the container filesystem can be viewed using the ‘docker diff’ command as:</p><p><strong>Command:</strong> </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly bash"><div tabindex="0" class="prism-code language-bash codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">docker </span><span class="token function" style="color:rgb(130, 170, 255)">diff</span><span class="token plain"> 7d0d0225778c</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Commit the changes in container</p><p>Docker commit:</p><p>Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p><p>docker commit -m &#x27;new Ubuntu image&#x27; 7d0d0225778c divyabhushan/learn_docker:ubuntu14.04_v2</p><p>New image is created and listed</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-4-push-1"></a><strong>Step 4: push</strong><a class="hash-link" href="#step-4-push-1" title="Direct link to heading">#</a></h3><p>Push new image to docker hub</p><p><strong>Command:</strong></p><p>docker push divyabhushan/learn_docker:ubuntu14.04_v2</p><p>Point to note: just the latest commit change layer ‘50a5ce553bba’ has been pushed, while the other layers were re-used.</p><p>Image available on docker hub:</p><p>The latest tagged image can now be pulled from other machines; and run to create the same container environment.</p><p><strong>Conclusion</strong>: An image was pulled and run to create a container to replicate the environment. Container was modified, new changes were committed to form a new image. New Image pushed back on the docker hub and now available as a new tag ready to be pulled by other machines.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="difference-between-dockers-and-virtual-machines"></a><strong>Difference between Dockers and Virtual machines</strong><a class="hash-link" href="#difference-between-dockers-and-virtual-machines" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tabular-differences-on-various-parameters"></a><em>Tabular differences on various parameters</em><a class="hash-link" href="#tabular-differences-on-various-parameters" title="Direct link to heading">#</a></h3><table><thead><tr><th>Parameters</th><th>VMs</th><th>Dockers</th></tr></thead><tbody><tr><td>architecture</td><td>Hardware-level virtualization. Each VM has its own copy of OS.</td><td>Software level virtualization. Dockers have no own OS, run on host OS</td></tr><tr><td>Isolation</td><td>Fully isolated</td><td>Process or application-level isolation.</td></tr><tr><td>Installation</td><td>Hypervisor can run directly on the hardware resources or on the host OS.</td><td>Docker engine is installed on top of the host OS. A docker daemon process is initiated on the host OS. There is no separate OS for every container.</td></tr><tr><td>CPU processing + performance</td><td>Slower: A VM contains the entire run-time environment that has to be loaded every time. Uses more CPU cycles; gives unstable performance.</td><td>Faster: Docker images are pre-built and share host resources as a result running an image as a container is lightweight and consumes less CPU cycle; gives a stable performance</td></tr><tr><td>Hardware storage</td><td>More storage space as each VM is an independent machine (OS). Example: 3 VMs of 800MB each will take 2.4 GB of space.</td><td>Docker containers are lightweight since do not require to load OS+drivers, run on host OS as processes.</td></tr><tr><td>Portable</td><td>Dependency on host OS and hardware makes VM less portable. Importing a VM still requires manual setup such storage, RAM and network.</td><td>Highly portable since lightweight and zero dependency on hardware.</td></tr><tr><td>Scalable and code-reusability</td><td>Spinning up more VMs still need administrative tasks such as distributing resources to VM. Running a new machine puts extra load on the system resources also re-managing earlier VMs becomes a task. Every VM keeps its own copy of resources-poor code-reusability.</td><td>Spinning up new docker containers simply means running pre-built images into containers as a process inside host OS. Containers are also configured on-the-fly passing parameters and run-time. Single image can be run and used to create many containers; encourage code-reusability</td></tr><tr><td>Resource utilization</td><td>Static allocation results in resource wastage in case of idle VMs or if a VM’s resource requirement increases.</td><td>Resources are dynamically allocated and de-allocated on the need basis by the docker engine.</td></tr><tr><td>Docker system prune or garbage collection</td><td>Virtual machines do not have an in-built prune mechanism, these have to be administered manually.</td><td>Docker image and containers can be pruned; which frees up a sensible amount of storage and memory space and CPU cycles.</td></tr><tr><td>New environment</td><td>Creating new VM from the scratch is a tedious, repetitive tasks. It involves installing a new OS, loading kernel drivers and other tools and configurations.</td><td>Package the code and dependency files, build into an image, run the image to create a new container. Use an existing or a base image (dockerhub- scratch) to run and create more containers on the go.</td></tr><tr><td>Web-hosted Hub</td><td>No web hosted hub for VMs</td><td>dockerHub provides an open-source reliable trusted source of pre-built images that can be downloaded to run new containers.</td></tr><tr><td>Version control (backup, restore,track history)(refer git)</td><td>Snapshot of VMs are not very user-friendly and consume more space.</td><td>Docker images are version controlled. Every delta difference in each docker container can easily be viewed (demo: docker diff ). Any change in the image is stored as a different layered version. A reference link to older images saves build time and space.</td></tr><tr><td>Auto-build</td><td>Automation of creating VMs is not very feasible.</td><td>Docker images can also be auto-built from every source code check-in to GitHub (Automated builds on Dockerhub)</td></tr><tr><td>Disaster recovery</td><td>Tedious to recover from VM backup files.</td><td>Easier to restore docker images (like files) just like git source files in case images are version controlled. Backup images only have to be run to create containers. (refer: screenshot).</td></tr><tr><td>Update</td><td>All the VMs have to updated with the release patch.</td><td>A single image is updated, re-built and distributed across multiple platforms.</td></tr><tr><td>Memory usage+speed</td><td>Slower: Entire snapshot of a machine and the OS is loaded into the cache memory.</td><td>Real-time and fast: pre-built images. Only the instance, i.e, a container has to be run as a process and uses memory like an executable</td></tr><tr><td>Data integrity</td><td>VM behavior may change if the dependency includes beyond the VM boundaries. (example: an app depends on production host network settings)</td><td>Same behavior of apps in any environment</td></tr><tr><td>security</td><td>More secure: A failure inside a VM may reach its guest OS but not the host OS or other virtual machines. Type-2 hypervisor though has a risk of kernel attack.</td><td>Less secure: If a docker container compromised; underlying OS and hence all the containers may be affected since they share the same host kernel. OS Kernel may also be risked.</td></tr><tr><td>Key providers</td><td>Red hat KVM, VMWare, Oracle VM VirtualBox, Mircrosoft Hyper-V, Citrix XenServer</td><td>Dockers, Google kubernetes Engine, AWS Elastic Container service</td></tr><tr><td>Data authentication</td><td>Lot of software licenses.</td><td>Docker maintains inbuilt content trust to verify published images.</td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="when-to-use-vm-or-a-docker"></a><em>When to use VM or a Docker</em><a class="hash-link" href="#when-to-use-vm-or-a-docker" title="Direct link to heading">#</a></h2><p>When the need is an isolated OS, go for VMs.</p><p>For a hardware and software independent isolated application that needs fast distribution on multiple environments, use dockers.</p><ul><li><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="docker-use-case"></a>Docker use-case:<a class="hash-link" href="#docker-use-case" title="Direct link to heading">#</a></h3></li></ul><p>Example: A database application along with its database</p><p>Consider the docker image - <a href="https://hub.docker.com/_/oracle-weblogic-server-12c?tab=description" target="_blank" rel="noopener noreferrer">Oracle WebLogic Server</a> on <a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">Docker Hub</a>.</p><p>This image is pre-built Oracle WebLogic Server runtime environment, including Oracle Linux 7 and Oracle JDK 8 for deploying Java EE applications.</p><p>To create Server configurations on any machine, just download this image and run to create and start a container.</p><p>There is no need to install and configure JDK, Linux or other run-time environment.</p><ul><li><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="do-not-use-docker-use-case"></a>Do not use Docker use-case:<a class="hash-link" href="#do-not-use-docker-use-case" title="Direct link to heading">#</a></h3></li></ul><p>The application depends on utility outside the docker container.</p><p>Code developed on dev machine with base OS as MAC; needs certain firewall setting on say Ubuntu OS.</p><p>How can the code be tested on the production ubuntu OS firewall while running from MAC OS docker container?</p><p>Solution:  Install a virtualization software on host OS-MAC; Create a VM (Virtual machine) with host OS as Ubuntu (same as production environment).</p><p>Configure the desired firewall settings on host VM – Ubuntu; import the test code inside Ubuntu and test.</p><ul><li><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="use-a-vm"></a>Use a VM:<a class="hash-link" href="#use-a-vm" title="Direct link to heading">#</a></h3></li></ul><p>For Embedded systems programming, a VM is installed that connects to the system device drivers, controllers and kernel.</p><ul><li><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="virtualization-used-along-with-docker"></a>Virtualization used along with docker:<a class="hash-link" href="#virtualization-used-along-with-docker" title="Direct link to heading">#</a></h3></li></ul><p>An extension to the previous scenario would be if you would want to also test your python application in the host OS-Ubuntu VM without having to set up the python exe and its libraries and binaries.</p><p>All you have to do is: Install <a href="https://www.knowledgehut.com/devops/docker-training" target="_blank" rel="noopener noreferrer">Docker</a> engine for Ubuntu OS and pull the python image from Docker hub as:</p><p>docker pull python:tag [ tag is the python version-choose the appropriate version ]</p><p>docker pull python:2.7</p><p>Refer: <a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener noreferrer">Python image</a></p><p>Either write a Dockerfile to import/copy entire source code to python environment or directly run the image passing the script path as below:</p><p>Command:</p><p>$docker run -it --name my-python-script -v “$PWD”:/usr/src/myapp -w /usr/src/myapp python:2.7 python my-application.py</p><p>Command options:</p><p>-v = volume list-bind mount a volume [mount present working directory onto /usr/src/myapp inside container]</p><p>-w = workdir string-working directory inside the container</p><p>Moreover; you can also test your python code in more than one version by downloading different python images, running them to create different containers and running your app in each container.</p><p>What’s exciting here is that once the code tested in each python environment; you could quickly work on the test results and drop the containers. And deploy the code to production only once code tested against various python versions.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="final-thoughts"></a><em>Final thoughts</em><a class="hash-link" href="#final-thoughts" title="Direct link to heading">#</a></h4><p>VMs and dockers are compatible with each other. Dockers are not here to replace Virtual machines.</p><p>Both serve the same purpose of virtualizing the computing and infrastructure resources for optimized utilization.</p><p>Using both Virtual machines and dockers together can yield better results in virtualization.</p><p>When one desires a fast, lightweight, portable and highly scalable hardware-independent environment for multiple applications isolation; wherein security is not the major concern; Dockers is the best choice.</p><p>Use a VM for embedded systems that are integrated with hardware; such as device driver or kernel coding.</p><p>A scenario simulating an infrastructure setup with a high resource control and dependency on system resources; VMs are a better choice.</p><p>Use of Dockers inside VM</p><p>CI/CD pipelines scenario:</p><p>Virtualization enables a smooth CI/CD process flow by promoting the users to concentrate only on developing the code on a working system that is set up for automated continuous integration and deployment without having to duplicate the entire setup each time.</p><p>A virtualized environment is set up; either using a VM or a docker image that takes care of the automatic code check-ins, builds, regression testing, and deployments on the server.</p><blockquote><p>Originally posted on <a href="https://www.knowledgehut.com/blog/devops/docker-vs-vm" target="_blank" rel="noopener noreferrer">KnowledgeHut</a></p></blockquote></div></article><div></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/profile/blog/2019/06/10/devops-interview-questions-answers"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« DevOps Interview Questions and Answers - Part I - Basics</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></main><div class="col col--2"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#what-a-machine-needs" class="table-of-contents__link">What a machine needs?</a></li><li><a href="#how-to-manage-huge-data---servers" class="table-of-contents__link"><strong>How to manage huge data - Servers</strong></a><ul><li><a href="#many-servers-approach-challenge" class="table-of-contents__link"><strong>Many Servers approach challenge:</strong></a></li></ul></li><li><a href="#virtualization" class="table-of-contents__link"><strong>Virtualization</strong></a><ul><li><a href="#what-is-virtualization" class="table-of-contents__link">What is Virtualization</a></li><li><a href="#what-is-a-virtual-machine" class="table-of-contents__link"><em>What is a Virtual machine</em></a></li><li><a href="#need-for-virtualization" class="table-of-contents__link"><em>Need</em> <em>for</em> <em>virtualization</em></a></li></ul></li><li><a href="#implementation" class="table-of-contents__link"><em>Implementation</em></a><ul><li><a href="#a-what-is-hypervisor-and-its-types__" class="table-of-contents__link"><em>a) What is hypervisor and its types__?</em></a></li><li><a href="#b-comparing-hypervisor-types" class="table-of-contents__link"><em>b) Comparing hypervisor types</em></a></li></ul></li><li><a href="#types-of-virtualization" class="table-of-contents__link"><em>Types of virtualization</em></a></li><li><a href="#containerization" class="table-of-contents__link"><strong>Containerization</strong></a></li><li><a href="#what-is-containerization" class="table-of-contents__link"><em>What is containerization</em></a></li><li><a href="#what-is-a-docker" class="table-of-contents__link"><em>What is a Docker</em></a><ul><li><a href="#ppt-diagram" class="table-of-contents__link"><strong>Ppt diagram:</strong></a></li><li><a href="#what-is-the-container-environment" class="table-of-contents__link">What is the container environment?</a></li></ul></li><li><a href="#how-to-modify-and-build-your-own-app" class="table-of-contents__link"><em>How to modify and build your own app</em></a><ul><li><a href="#step-1-pull" class="table-of-contents__link"><strong>Step 1: pull</strong></a></li><li><a href="#step-2-modify" class="table-of-contents__link"><strong>Step 2: modify</strong></a></li><li><a href="#step-3-commit" class="table-of-contents__link"><strong>Step 3: commit</strong></a></li><li><a href="#step-4-push" class="table-of-contents__link"><strong>Step 4: push</strong></a></li><li><a href="#step-1-pull-1" class="table-of-contents__link"><strong>Step 1: pull</strong></a></li><li><a href="#step-2-modify-1" class="table-of-contents__link"><strong>Step 2: modify</strong></a></li><li><a href="#step-3-commit-1" class="table-of-contents__link"><strong>Step 3: commit</strong></a></li><li><a href="#step-4-push-1" class="table-of-contents__link"><strong>Step 4: push</strong></a></li></ul></li><li><a href="#difference-between-dockers-and-virtual-machines" class="table-of-contents__link"><strong>Difference between Dockers and Virtual machines</strong></a><ul><li><a href="#tabular-differences-on-various-parameters" class="table-of-contents__link"><em>Tabular differences on various parameters</em></a></li></ul></li><li><a href="#when-to-use-vm-or-a-docker" class="table-of-contents__link"><em>When to use VM or a Docker</em></a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">
      <div class="footer">
      <p style="float:left">
      Built with Docusaurus and powered by JSX and React!!!
      </p>
      <p style="float:right">
      <a href="https://www.linkedin.com/in/divyabhushan/" target="_blank" style="padding-left:10px"><img src="https://github.com/divyabhushan/my-portfolio/blob/gh-pages/img/linkedin.png?raw=true" width="40">
      <a href="https://divya-bhushan.medium.com/" target="_blank" style="padding-left:10px"><img src="https://github.com/divyabhushan/my-portfolio/blob/gh-pages/img/medium.png?raw=true" width="40"></a>
      <a href="https://github.com/divyabhushan"><img src="https://raw.githubusercontent.com/divyabhushan/my-portfolio/gh-pages/img/github.svg" width="40"></a>      
      </p><p>
      </p></div>
      </div></div></div></footer></div>
<script src="/profile/assets/js/runtime~main.96f30e45.js"></script>
<script src="/profile/assets/js/main.74a5d44d.js"></script>
</body>
</html>